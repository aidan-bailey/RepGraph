package com.repgraph.models;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Component;

@Component
public class DMRSLibrary {

    private ArrayList<Graph> dmrsGraphs;

    /**
     * Constructor which takes in the name of a file containing DMRS graphs in JSON
     * format and parses them into the dmrsGraphs object
     * 
     * @param fileName the name of the file containing dmrs graphs in JSON format
     */
    public DMRSLibrary(String fileName) {
        dmrsGraphs = new ArrayList<Graph>();
        JSONParser jparser = new JSONParser();
        try (BufferedReader file = new BufferedReader(new FileReader(fileName))) {
            String graph = "";
            while ((graph = file.readLine()) != null) {
                Object graphObj = jparser.parse(graph);
                JSONObject jGraph = (JSONObject) graphObj;
                dmrsGraphs.add(new Graph(jGraph));
            }
        } catch (IOException | ParseException e) {
            e.printStackTrace();
        }
    }

    /**
     * Find all the graphs that contains nodes with the given labels. Nodes in the
     * graph that match the labels are marked. Note there should be no duplicated in
     * the labels
     * 
     * @param labels the list of unique labels that are to be searched for in the
     *               graphs
     * @return a list of graphs that contains nodes with all the given labels
     */
    public ArrayList<Graph> findPatternSimple(ArrayList<String> labels) {
        ArrayList<Graph> matchedGraphs = new ArrayList<>();
        for (Graph g : dmrsGraphs) {
            if (graphMatch(g, labels)) {
                matchedGraphs.add(g);
            }
        }
        return matchedGraphs;
    }

    /**
     * Find all the graphs that contain the subgraph generated by the given node.
     * Pattern matches in the nodes and edges of the graph are marked
     * 
     * @param node the node representing the subgraph pattern to be searched for
     * @return a list of graphs which contain the subgraph pattern
     */
    public ArrayList<Graph> findPattern(Node node) {
        ArrayList<Graph> matchedGraphs = new ArrayList<>();
        PatternMatch p = new PatternMatch(node);
        for (Graph g : dmrsGraphs) {
            if (p.graphMatch(g)) {
                matchedGraphs.add(g);
            }
        }
        return matchedGraphs;
    }

    // match node labels in a graph. Label nodes that match pattern
    // make sure there is only one of each label in the list, no duplicates
    // check nodes in graph. If graph contains nodes with all the labels in the
    // list, the graph contains the pattern
    // Note, there may be multiple nodes in the graph with a given label, all must
    // be found and labelled
    private boolean graphMatch(Graph g, ArrayList<String> labels) {
        // reset match variables for the graph
        g.resetGraphMatches();
        // initialize a list to keep track of whether a label has a match
        boolean[] matched = new boolean[labels.size()];
        for (Node n : g.getNodes()) {
            String nodeLabel = n.getLabel();
            for (int i = 0; i < labels.size(); i++) {
                // if a label matches one of the labels in the list, set label match to true,
                // set corresponding variable
                // in matched to true for the label and stop looping since a node can only have
                // one label and there should
                // only be one of each label in the list of match labels
                if (nodeLabel.equals(labels.get(i))) {
                    n.setLableMatch(true);
                    matched[i] = true;
                    break;
                }
            }
        }
        // loop through array to check that all labels are matched
        for (boolean b : matched) {
            // if at least one label does not match, the graph does not match
            if (!b)
                return false;
        }
        return true;
    }

    /**
     * Find and return the graph stored at the given index. Null is returned if the
     * index is invalid i.e. larger than the number of graphs in the array or if the
     * index is negative
     * 
     * @param index the index of the graph to be returned
     * @return the graph at the given index or null if the index is invalid, of type
     *         Graph
     */
    public Graph getGraph(int index) {
        // return null if graph index requested is out of range
        if (index >= dmrsGraphs.size() || index < 0) {
            return null;
        }
        return dmrsGraphs.get(index);
    }

    /**
     * DMRSLibrary default constructor
     */
    public DMRSLibrary() {
        dmrsGraphs = new ArrayList<>();
    }

    /**
     * Contructor which takes in a list of dmrsGraphs and assigns it to the class.
     * This method is mainly for testing
     * 
     * @param graphs the list of graphs to be used
     */
    public DMRSLibrary(ArrayList<Graph> graphs) {
        dmrsGraphs = graphs;
    }

    /**
     * Return a list of the DMRSgraphs
     * 
     * @return dmrsGraphs, the list of dmrsGraphs
     * 
     *         /** Gets dmrs graph list
     * @return
     */
    public List<Graph> getGraphs() {
        return dmrsGraphs;
    }

    /**
     * Get number of dmrs graphs stored
     * 
     * @return
     */
    public int getCount() {
        return dmrsGraphs.size();
    }

}